#Title: GainCalibration
#Description: find the DT5202 gain setting to scale the output of a channel by a given factor
#Arguments: 1. Run number of initial calibration run, 2. list of inital gain settings (comma separated)
#target MPV of channel you want to calibrate

import pandas
import sys
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as fit

fitrange = (20,1200)
gainsetting = str(sys.argv[2]).split(",")
for i in range(len(gainsetting)):
	gainsetting[i] = int(gainsetting[i])

chlist = ['00','01','02','03','08','09','10','11']
triggercombos = [["08","10"],['09','11']]
channelcombos = [[1,3],[0,2]]
nhodochannels = 4

def calibrate(run_i, gs_i): #arguments: initial run number, initial gain settings
        ch_lg = {}
        ch_hg = {}

        #event count
        npath = 2*[0]
        neventstotal = 0

        for ch in range(4):
            ch_hg[ch] = []
            ch_lg[ch] = []
        def readevent(infile): #read one event and add appropriate channels to histogram
            time = 0
            hodohits = []
            lg = []
            hg = []
            for ch in range(4):
                line = infile.readline()
                if not line: return False, time
                while ("//" in line) or ("Tstamp" in line): line = infile.readline()
                if (ch==0):
                    time = float(line.split()[0])
                    lg.append(float(line.split()[4]))
                    hg.append(float(line.split()[5]))
                else:
                    lg.append(float(line.split()[2]))
                    hg.append(float(line.split()[3]))
            for hodo in range(len(chlist)-4):
                line = infile.readline()
                if not line: return False, time
                if float(line.split()[2])> 280:
                    #print(line.split()[2])
                    hodohits.append(chlist[hodo + 4])
            for i in range(2):
                combo = triggercombos[i]
                if (combo[0] in hodohits) and (combo[1] in hodohits):
                    npath[i] += 1
                    ch1 = channelcombos[i][0]
                    ch2 = channelcombos[i][1]
                    ch_lg[ch1].append(lg[ch1])
                    ch_lg[ch2].append(lg[ch2])
                    ch_hg[ch1].append(hg[ch1])
                    ch_hg[ch2].append(hg[ch2])
            return True, time





        linegood = True
        homedir = "/home/cmiller6/"
        with open("Run"+str(run_i)+"_list.txt") as infile:
          if nhodochannels == 0:
            for line in infile:
              if ("//" in line): continue
              if ("Tstamp" in line): continue
              for ch in chlist:
                if ("00  "+chlist_str[ch] in line):
                  if (ch==0):
                    nevents+=1
                    ch_lg[ch].append(float(line.split()[4]))
                    ch_hg[ch].append(float(line.split()[5]))
                  else:
                    ch_lg[ch].append(float(line.split()[2]))
                    ch_hg[ch].append(float(line.split()[3]))
          else:
            while linegood:
                linegood, time = readevent(infile)
                if (linegood): time_s = time*10**(-6)

        #choose to plot with matplotlib rather than ROOT because not sure where ROOT is installed
        def gauss(x,a,b,d):
            f = b*np.exp(-d*(x-a)**2)
            return f

        #make a histogram for each channel.
        mpv = []
        mpverr = []
        plt.figure()
        colors = ['red','green','black','blue']
        for i in range(4):
          #fit
            hist,bins = np.histogram(ch_hg[i], range = fitrange,bins=25)
            #find bin centers
            bin_center = []
            for j in range(len(bins)-1):
                bin_center.append((bins[j]+bins[j+1])/2)
            '''popt,pcov = fit.curve_fit(gauss,np.array(bin_center),hist,p0=[500,10,.0001])
            perr = np.sqrt(np.diag(pcov))
            mpv.append(popt[0])
            mpverr.append(perr[0])'''
            #find average of histogram
            clipped = []
            for j in range(len(ch_hg[i])):
                if (ch_hg[i][j] < fitrange[1]) and (ch_hg[i][j] > fitrange[0]):
                    clipped.append(ch_hg[i][j])
            mpv.append(np.average(np.array(clipped)))
            mpverr.append(np.std(np.array(clipped))/np.sqrt(len(clipped)))

            #plot
            #plt.errorbar(bin_center,hist,label="Channel "+str(i),yerr = np.sqrt(hist),color=colors[i],fmt='o',elinewidth=1,marker='o')
            plt.hist(ch_hg[i],bins=50,label="Channel "+str(i),color=colors[i],fill=False,histtype='step',edgecolor=colors[i],range=fitrange)
            x = np.arange(*fitrange,1)
            #plt.plot(x,gauss(x,*popt),color=colors[i])
            ylim = plt.gca().get_ylim()
            plt.ylim(ylim)
            plt.plot(np.repeat(mpv[i],1000),np.arange(0,1000,1),color=colors[i],linestyle = "dotted", label = "Channel "+str(i)+" mean")
            plt.xlim(*fitrange)
            plt.xlabel("ADC (High Gain)")
            plt.ylabel("Counts")
            plt.title("Inter-Channel Gain Calibration, Run "+sys.argv[1])
            plt.legend()
        plt.savefig("gaincalibration_Run"+str(sys.argv[1])+".pdf")
        plt.savefig("gaincalibration_Run"+str(sys.argv[1])+".png")

        print("MPV = ")
        print(mpv)
        print("MPV_err =")
        print(mpverr)

        #for now, adjust all peaks to align with highest peak
        mpvmax = np.max(mpv)

        def find_nearest(array, value): #returns index of first component in array that is higher than "value"
            i = 0
            #print(array[i])
            #print(value)
            while array[i] < value:
                i += 1
            return i

        #function to find gain setting
        def find_gain(gf, gs, gs_initial, MPV_f, MPV_i):
            target = MPV_f/MPV_i #target change factor
            #plt.style.use(hep.style.ROOT)
            init = gf[np.where(gs == gs_initial)[0]] #initial gain factor
            target_gf = target*gf[np.where(gs == gs_initial)[0]] #target gain factor
            '''if target_gf < 1:
                print("Error: gain factor cannot be less than 1")
                return 1'''
            i = find_nearest(gf, target_gf)
            slope = (gf[i]-gf[i-1])/(gs[i]-gs[i-1])
            x = (target_gf - gf[i])/slope
            closest_gs = gs[i] + np.round(x)
            print("The closest gain setting is "+str(closest_gs))
            print("This will give an estimated MPV of "+str(np.round((slope*np.round(x)+gf[i])/init*MPV_i,0)))
            '''
            plt.figure()
            plt.title("Gain Factor vs. DT5202 Gain Setting")
            plt.ylabel("Gain Factor (MPV/MPV$_{GS=1}$)")
            plt.xlabel("Gain Setting")
            plt.errorbar(gs, gf,yerr=gf*.06,fmt='o',markersize=3,label="experimental gain factor (linear interpolation)",linestyle="dotted", color='red')
            plt.plot(gs,np.repeat(target_gf,len(gs)),label="target gain factor = "+str(np.round(target_gf,3)[0]),color='green')
            plt.plot(gs,np.repeat(init,len(gs)),label="initial gain factor = "+str(np.round(init,3)[0]),color='blue')
            plt.legend()
            plt.savefig("gaincalib.png")
            '''

        df = pandas.read_csv("gainscan_scaled.csv", names = ["gain","gainfactor","gferr","res","reserr"])

        gs = np.array(df['gain'])
        gf = np.array(df['gainfactor'])

        #calculate run length
        time_str = ""
        hours = int(np.round(time_s/3600))
        if hours != 0: time_str += str(hours) + " h, "
        min = int(np.round(np.mod(time_s,3600)/60))
        if min != 0: time_str += str(min) + " m, "
        s = int(np.round(np.mod(time_s,60)))
        time_str += str(s) + " s"
        print("\nNumber of events passing trigger path 1: "+str(npath[0]))
        print("Number of events passing trigger path 2: "+str(npath[1]))
        print("Total events passing selection: "+str(npath[0]+npath[1]))
        print("Run length: "+time_str)
        print("Event rate (passing selection): "+str(np.round((npath[0]+npath[1])/time_s,5))+" Hz \n")
        #find new gain settings to calibrate
        for i in range(4):
            print("Channel "+str(i))
            find_gain(gf,gs,gs_i[i],mpvmax,mpv[i])

calibrate(sys.argv[1],gainsetting)



